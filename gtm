#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

VERSION="0.5.1"

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

# Text color variables
tund=$(tput sgr 0 1) # underline
tbld=$(tput bold)    # bold
tred=$(tput setaf 1) # red
tgrn=$(tput setaf 2) # green
tyel=$(tput setaf 3) # yellow
tblu=$(tput setaf 4) # blue
tgry=$(tput setaf 8) # gray
trst=$(tput sgr0)    # reset
# Surroungings
txtsurround() { printf "${1}${2}${trst}" "${@:3}"; }
red()    { txtsurround $tred "$@"; }
green()  { txtsurround $tgrn "$@"; }
yellow() { txtsurround $tyel "$@"; }
blue()   { txtsurround $tblu "$@"; }
gray()   { txtsurround $tgry "$@"; }
bold()   { txtsurround $tbld "$@"; }
underline() { txtsurround $tund "$@"; }

# some common printing functions
err() {
    red "$1\n" 
    [ "$2" ] && echo "$2"
    exit 1
}
confirm() {
    echo "$1"
    read -n 1 -p "`gray "[press any key to continue]"`"
    # now go up one line and erase it
    tput cuu1 && tput el
    echo
}
overview() {
    echo `bold "Operation overview:"`
    for s in "$@"; do
        echo $s
    done
    read -n 1 -p "`gray "[review steps and press any key to continue]"`"
    local n=$(( $# + 2 ))
    until (( n == 0 )); do
        tput cuu1 && tput el
        n=$(( n - 1 ))
    done
}
failed() {
    local result=$1
    local msg=${2:-"Previous step has failed"}
    if (( $result != 0 )); then
        echo `red "$msg"`
        read -n 1 -p "`gray "[press Ctrl-C to stop or any other key to continue]"`"
        tput cuu1 && tput el
        echo
    fi
}

### USAGE

general_help="
gtm v.$VERSION - git task/time manager (c) Alexey Alekhin

`bold 'Usage'`: `blue 'gtm command [options]'`

`bold 'General commands'`:
    `green 'usage|-h|--help|help'`  -- show this mesage
    `green 'version|-v|--version'`  -- show current version
    `green init`                  -- set gtm configuration (hooks and git-config); run this in every new repository

`bold 'Timer commands'`:
    `green start` <[+-]time>      -- start timer (setting time if given)
    `green stop` <[+-]time>       -- pause timer (setting time if given)
    `green set` <[+-]time>        -- set/add/subtract spent time (see help for time formats); `green set` word can be ommited
    `green status` [flags]        -- show current timer state (see `blue 'gtm help status'` for possible flags)
    `green timesince`             -- set time spent since last commit
    `green steal`                 -- steal all time from another task (master by default) and move it to the current task
          [-i <issue>]       pick task by issue number
       or [-b <branch>]      pick task by branch name
    `green list`                  -- list all tasks with issue numbers and timers information
    `green summary`               -- print summary of spent time by authors
    `green log`                   -- same as git-log but with human-format time notes

`bold 'Commits related commands'`:
    `green undo`   [<number>]     -- (soft) reset given number of commits (1 by default) and return their time
    `green amend`  [<commit_sha>] -- set currently spent time to the given commit (HEAD by default)
    `green delete` [<commit_sha>] -- delete timer note of given commit (HEAD by default)
    `green merge`  [<remote>]     -- merge timetracker notes from remote branch (origin by default)
    `green push`                  -- pushes current branch (setting upstream) and pushes timetracker notes

`bold 'Task commands'`:
    `green task` <name> <options> -- create new task
    `green connect` [options]     -- transform bound issue to pull-request if possible
    `green info`                  -- show info about task branch, timer and the bound issue 
    `green switch` <number>       -- switch between tasks by issue number
    `green close`                 -- close current task

    Use `blue 'gtm help <command>'` for more information about options and behaviour
"
function show_help {
    (( $# == 0 )) && echo "$general_help" && exit 0
    case $1 in
        status|set|start|stop|amend|task|connect|info|switch|close)
            gtm $1 --help
        ;;
        *)
            err "No help entry for '$1'"
        ;;
    esac
}


### HOOKS

function pre_commit_hook() {
echo '#!/bin/bash
# check if the timer is not zero
time=$(gtm status --seconds)
if (( $time == 0 )); then
    echo "`tput setaf 1`You forgot to set the timer!`tput sgr0`"
    exit 1
fi'
}


function post_commit_hook() {
echo '#!/bin/bash

running=$(git config timetracker.start)
gtm stop > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config branch.$current_branch.spent)
git config --unset branch.$current_branch.spent

if (( ${spent:-0} > 0 )); then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $running ] && gtm start > /dev/null
    echo "Time-spent: $(gtm human-time $spent)"
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    gtm merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

if (( $3 == 1 )) # if branch is switched
then
    old_branch=$(git config timetracker.branch)
    start=$(git config timetracker.start)
    spent=$(git config branch.$old_branch.spent)
    now=$(date +%s)

    # save state of old branch
    [ $start ] && spent=$(( $spent + $now - $start ))
    git config branch.$old_branch.spent ${spent:-0}
    git config --unset timetracker.start

    # use new branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git config timetracker.branch $current_branch
    [ "$start" ] && gtm start &> /dev/null

    gtm list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    local s=${1:-0}
    s=${s#-} # removing - sign
    local m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    local h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    if [ "$2" == "--short" ]; then
        (( $h < 10 )) && hh=" $h:" || hh="$h:"
        (( $m < 10 )) && mm="0$m:" || mm="$m:"
        (( $s < 10 )) && ss="0$s"  || ss="$s"
        echo " $hh$mm$ss"
    else 
        (( $h >  0 )) && printf "%2d hours "    $h
        (( $m >  0 )) && printf "%2d minutes "  $m
        (( $s >= 0 )) && printf "%2d seconds\n" $s
    fi
}

function start_date() { git config timetracker.start; }
function start_from_now() { git config timetracker.start $(date +%s); }

function spent_get() { 
    local branch=${1:-$(current_branch)}
    local spent=$(git config branch.$branch.spent)
    [ ! $spent ] && git config branch.$branch.spent 0
    echo ${spent:-0}
}
function spent_set() {
    local branch=${2:-$(current_branch)}
    git config branch.$branch.spent $1
}

function current_branch() { git rev-parse --abbrev-ref HEAD; }

function current_time() {
    local start_date=$(start_date)
    local current_date=$(date +%s)
    local spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    local alltimes=$(git log --author="$1" --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

function on_status() { [ $(start_date) ] && green "  [on]" || red " [off]"; }

function gitdir() { echo "$(git rev-parse --git-dir 2> /dev/null)"; }
function gitroot() { echo "$(git rev-parse --show-toplevel 2> /dev/null)"; }

### SUBCOMMANDS

function gtm_start() {
    local help_msg="
`bold Usage`: `blue 'gtm start'` `green '[<[+-]time>]'`

Starts the timer and sets it's value if it's given (see `blue 'gtm help set'`)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    [ ! $(gitdir) ] && err "It's not a git root directory!"

    [ "$1" ] && gtm_set $1 > /dev/null

    local running_repo=$(git config --global timetracker.repo)
    local current_repo=$(gitroot)
    if [ "$running_repo" == "$current_repo" ] && [ $(start_date) ]; then
        gtm_status
    else
        [ "$running_repo" ] && [ "$running_repo" != "$current_repo" ] && gtm_stop
        start_from_now
        spent_get > /dev/null
        git config --global timetracker.repo "$current_repo"
        echo "`gtm_status --no-label` `green [started]`"
    fi
}

function gtm_stop() {
    local help_msg="
`bold Usage`: `blue 'gtm start'` `green '[<[+-]time>]'`

Stops the timer and sets it's value if it's given (see `blue 'gtm help set'`)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local running_repo=$(git config --global timetracker.repo)
    if [ ! "$running_repo" ]; then
        [ ! $(gitdir) ] && err "No running timers"
        gtm_status
    else
        local current_dir=$(pwd -P)
        local current_repo=$(gitroot)
        [ "$running_repo" != "$current_repo" ] && cd "$running_repo"
        spent_set $(current_time)
        git config --unset timetracker.start
        [ "$1" ] && gtm_set $1 > /dev/null

        printf "`gtm_status --no-label` `red [paused]`"
        [ "$running_repo" != "$current_repo" ] && echo " in `blue [$running_repo]`" || echo

        [ "$running_repo" != "$current_repo" ] && cd "$current_dir"
        git config --global --remove-section timetracker &> /dev/null
    fi
}

function gtm_tmp() {
    local help_msg="
`bold Usage`: `blue 'gtm tmp'` `green '[<description>]'`

Runs/stops temporary global timer, which can be added then to any repository/branch/task 
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    # [ "$1" ] && gtm_set $1 > /dev/null

    local running_repo=$(git config --global timetracker.repo)
    # local current_repo=$(gitroot)
    [ "$running_repo" ] && [ "$running_repo" != "tmp" ] && gtm_stop
    git config --global timetracker.repo "tmp"
    if 
        start_from_now
        echo "`gtm_status --no-label` `blue [tmp]`"
    fi
}

function gtm_status() {
    local help_msg="
`bold Usage`: `blue 'gtm status'` `green '[<flags>]'`

Shows current timer state. Optional flags are
 `bold '*'` `green '-g|--global'` - show status of running timer independently of where it is
 `bold '*'` `green '--seconds'`   - show time in seconds
 `bold '*'` `green '-s|--short'`  - show time in short format (hh:mm:ss)
 `bold '*'` `green '--no-label'`  - hide `green [on]`/`red [off]` status label
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local current_dir=$(pwd -P)
    while (( $# )); do
        case $1 in
            -g|--global) local global=1;;
            --seconds)   local seconds=1;;
            -s|--short)  local short="--short";;
            --no-label)  local no_label=1;;
            *) err "Wrong option: $1" "$help_msg";;
        esac
        shift
    done
    if [ $global ]; then
        local current_repo=$(git config --global timetracker.repo)
        [ ! "$current_repo" ] && err "No running timers"
        cd "$current_repo"
        echo -n "`pwd`: `blue "[$(current_branch)]"` "
    fi

    local spent=$(current_time)
    if [ "$seconds" ]; then 
        echo $spent && exit 0
    else
        echo -n "$(human_time $spent $short)"
    fi
    [ ! $no_label ] && echo -n $(on_status)
    echo
    [ "$current_repo" ] && cd "$current_dir"
    exit 0
}

function gtm_list() {
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local current_branch=$(current_branch)
    [ $(start_date) ] && gtm_stop > /dev/null && gtm_start > /dev/null
    local lwidth=10
    local rwidth=0
    for branch in $branches; do
        (( ${#branch} > lwidth )) && lwidth=${#branch}
        local spent=$(human_time $(git config branch.$branch.spent))
        (( ${#spent} > rwidth )) && rwidth=${#spent}
    done
    lwidth=$(( lwidth + 2 )) # for [...]

    [ ! "$1" == "--no-header" ] && underline "$(bold "  #  %-${lwidth}s %${rwidth}s \n" "Task" "Time spent")"
    for branch in $branches; do
        local spent=$(human_time $(git config branch.$branch.spent))
        local issue=$(git config branch.$branch.issue)
        if [ "$branch" == "$current_branch" ]
        then 
            [ $(start_date) ] && green "* " || red "* "
            yellow "%-2s " "$issue" 
            blue "%-${lwidth}s " "[$branch]" 
            printf  "%${rwidth}s"  "$spent"
            on_status
        else 
            yellow "  %-2s " "$issue" 
            blue "%-${lwidth}s " "[$branch]" 
            printf  "%${rwidth}s"  "$spent"
        fi
        echo
    done
}

function gtm_summary() {
    local alltimes=$(git log --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    local allusers=$(git log --format="%ae" | sort | uniq)
    local commits=$((`git log --oneline | wc -l`))
    local timed_commits=$((`git log --format="%N"  | grep "Time-spent:" | wc -l`))
    local percent=$(( $timed_commits * 100 / $commits ))
    echo "$timed_commits of $commits commits have time information ($percent%)"

    echo -n "Total time spent by authors in branch "
    blue "[$(current_branch)]\n"
    for author in $allusers; do
        local dedication=$(user_time_dedication $author)
        [ $dedication != 0 ] && printf " %-39s %s\n" "$author" "$(human_time $dedication)"
    done

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done
    printf "\n%-40s %s\n" "Total time spent in this branch" "$(human_time $total)"
}

# parses [+-]minutes or [+-]hours:minutes or [+-]hours:minutes:seconds and returns seconds
function parse_time() {
    local t=$1
    local sign=1
    local h=0
    local m=0
    local s=0
    [[ $t =~ ^\+ ]] && t=${t:1}
    [[ $t =~ ^- ]] && sign=-1 && t=${t:1}

    if [[ $t =~ ^[0-9]+:[0-9]+:[0-9]+$ ]]; then
        h=${t%%:*} # [h]: m : s
        m=${t#*:}  #  h :[m : s]
        s=${m#*:}  #      m :[s]
        m=${m%:*}  #     [m]: s
    elif [[ $t =~ ^[0-9]+:[0-9]+$ ]]; then
        h=${t%:*}
        m=${t#*:}
    elif [[ $t =~ ^[0-9]+$ ]]; then
        m=$t
    else
        err "Wrong time format"
    fi
    t=$(( h * 3600 + m * 60 + s ))
    echo $(( sign * t ))
}

function gtm_set() {
    local help_msg="
`bold Usage`: `blue 'gtm set'` `green '<[+-]time>'` or just `blue 'gtm'` `green '<[+-]time>'`

Sets, adds (with +) or subtracts (with -) given amount of time (without changing running state of the timer)
`green '<time>'` may be in one of the following formats:
 `bold '*'` `green 'hours:minutes:seconds'`
 `bold '*'` `green 'hours:minutes'`
 `bold '*'` `green '      minutes'`
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local t=$(parse_time $1) 
    [[ $t =~ Wrong ]] && err "Wrong time format" "$help_msg"
    if [[ $1 =~ ^[+-] ]]; then
        spent_set $(current_time)
        [ $(start_date) ] && start_from_now
        t=$(( $(spent_get) + $t ))
        local ht=$(human_time $t --short)
        (( $t < 0 )) && err "Negative time: -${ht##* }"
        spent_set $t 
    else
        spent_set $t
        [ $(start_date) ] && start_from_now
    fi
}

function gtm_add() {
    local help_msg="
`bold Usage`: `blue 'gtm add'` `green '[-]<minutes>'` or `blue 'gtm add'` `green '[-]<hours>:<minutes>'`

Adds or substracts time (without changing timer running state)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local t=$(parse_time $1) 
    [[ $t =~ Wrong ]] && err "Wrong time format"  "$help_msg"
    spent_set $(( $(spent_get) + $t ))
}

function gtm_amend() {
    local help_msg="
`bold Usage`: `blue 'gtm amend'` `green '[<commit_sha>]'`

Sets currently spent time to the commit with given sha (HEAD by default)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    sha=${1:-"HEAD"}
    running=$(start_date)
    gtm_stop > /dev/null
    spent=$(spent_get)

    if [ $spent ]; then 
        git notes --ref timetracker add -f -m "Time-spent: $spent" $sha
        echo "Time spent: $(human_time $spent)"
        spent_set 0
    fi
    [ $running ] && gtm_start > /dev/null
}

function gtm_push() {
    git push -u origin $(current_branch)
    git push
}

function gtm_steal() {
    case $1 in
        -i)
            local issue=$2
            [ ! "$issue" ] && gtm_list && err "Choose task number, from which you want to steal time"
            local branch=$(git config --get-regexp "branch.*.issue" | grep " $issue$" | cut -d "." -f 2)
            [ ! "$branch" ] && gtm_list && err "No task #$issue. Create a new one or choose from existing."
        ;;
        -b)
            local branch=$2
        ;;
    esac
    local branch=${branch:-master}
    local timer=$(spent_get $branch)
    spent_set $(( $(spent_get) + $timer ))
    spent_set 0 $branch
    green "Stolen time from branch "; blue "[$branch]"; echo ": `human_time $timer`"
}

function gtm_undo() {
    local n=${1:-1}
    local timers=$(git log -$n --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    git reset --soft HEAD~$n

    local total=0
    for t in $timers; do
        total=$(( $total + $t ))
    done
    spent_set $(( $(spent_get) + $total ))
    if (( $n == 1 )); then
        green "Undone last commit and returned it's time: "; echo "`human_time $total`"
    else
        green "Undone $n commits and returned their time: "; echo "`human_time $total`"
    fi
}

function gtm_task_new() {
    local help_msg="
`bold Usage`: `blue 'gtm task'` `green '<branch_name> <-i number | -m title> [issue_options]'`

Creates a task combining given branch and issue:

 `bold '*'` `green '<branch_name>'` can be an existing branch (use '`green -`' for current) or a name for new branch

 `bold '*'` If you want to bind task to an existing issue, use 
     `green '-i <number>'`
   else create a new one:
     `green '-m <issue_title>'`
   it will be assigned to you and it will get labels retrieved from the branch name prefix,
   i.e. if branch name is 'feature/topic/name', labels are 'feature' and 'topic'
 
   `green '[issue_options]'` are any options accepted by 'ghi open' (see 'ghi help open')
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local name=$1
    [ ! "$name" ] && err "Need a branch name for creating task (use '-' for current branch)" "$help_msg"
    [ "$name" == "-" ] && name=$(current_branch)

    local issue_flag=$2
    [ "$issue_flag" != "-i" ] && [ "$issue_flag" != "-m" ] && err "Wrong issue flag: $issue_flag" "$help_msg"
    local issue=$3

    local prefix=${name%/*}
    local labels=""
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    # info and confirmation
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local exists=$(echo $branches | grep "$name")
    if [ "$exists" ]; then
        local step1="`bold 1.` Use an existing branch `blue [$name]`"
    else
        local base=$(current_branch)
        local step1="`bold 1.` Create a new branch `blue [$name]` from `red [$base]`" 
    fi
    case $issue_flag in
        -i)
            local step2="`bold 2.` Bind the task to an existing issue `yellow \#$issue`:"
        ;;
        -m)
            local step2="`bold 2.` Bind the task to a new issue "$(yellow "\"$issue\"")
            [ "$labels" ] && step2=$step2" with tags: ${prefix//\//, }"
        ;;
    esac
    echo $step1
    echo $step2
    [ "$issue_flag" == "-i" ] && ghi show $issue
    confirm

    if [ ! "$exists" ]; then
        git checkout -b $name &> /dev/null
        git config branch.$name.base ${base:master}
    fi

    # issue binding
    case $issue_flag in
        -i)
            git config branch.$name.issue $issue
            echo "`green Issue` `yellow \#$issue` `green "is assigned to the task"`"
        ;;
        -m)
            local ghi_out=$(ghi open  --claim  $labels  "${@:2}")
            local number=$(echo $ghi_out | grep '#' | sed 's/^#\([0-9]*\):.*$/\1/')
            if [ "$number" ]; then 
                git config branch.$name.issue $number
                ghi show $number
                echo "`green Issue` `yellow \#$number` `green "is assigned to the task"`"
            fi
        ;;
    esac
    gtm_list
}

function gtm_task_connect() {
    local help_msg="
`bold Usage`: `blue 'gtm connect'` `green '[-t <task_branch>] [-b <base_branch>] [-i <issue_number>]'`

Connects task branch with and issue and transforms it to pull-request 
(to merge it into base branch) if possible (i.e. if there are any pushed commits).

By default
 `bold '*'` `green '<task_branch>'` is current branch
 `bold '*'` `green '<base_branch>'` is the branch from which the task was created
 `bold '*'` `green '<issue_number>'` is issue assigned to the <task_branch> (if it exists)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    while (( $# )); do
        case $1 in
            -t)
                [ ! $2 ] && err "Need an argument for -t: task that you want to connect" "$help_msg"
                local task=$2
                [ ! "$(echo $branches | grep "$task")" ] && err "Task [$task] doesn't exist:" "$(gtm_list)"
                ;;
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name" "$help_msg"
                local base=$2
                [ ! "$(echo $branches | grep "$base")" ] && err "Branch [$base] doesn't exist:" "$(git branch)"
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number" "$help_msg"
                local issue=$2
                ;;
            *)
                err "Wrong options: $*" "$help_msg" 
                ;;
        esac
        shift 2
    done
    local task=${task:-$(current_branch)}
    local base=${base:-$(git config branch.$task.base)}
    base=${base:-master}
    local issue=${issue:-$(git config branch.$task.issue)}
    if [ -z "$issue" ]; then
        red "Please provide issue number with -i option:\n"
        ghi list && exit 1
    fi

    git config branch.$task.issue $issue
    echo "`green Issue` `yellow \#$issue` `green "is assigned to the task"` `blue [$task]`"
    ghi edit --head $task --base $base $issue
    if (( $? != 0 )); then 
        red "Couldn't transform issue to pull-request. "
        echo "Push commits and try to connect again"
    fi
}

function gtm_task_close() {
    local help_msg="
`bold Usage`: `blue 'gtm close'` `green '[-b <base_branch>] [-i <issue_number>]'`

Closes current task in several steps:

`bold 1.` Try to merge task branch into base branch
`bold 2.` Push task branch
`bold 3.` Transform bound issue into a pull-request
`bold 4.` Push base branch and timetracker notes (it will close the issue)
`bold 5.` Delete task branch and move the time remained on it to the base branch

By default `green '<base_branch>'` is master and `green '<issue_number>'` is the issue assigned to the current task
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local task=$(current_branch)
    [ "$task" == "master" ] && err "You are on [master] branch. Swith to the task, that you want to close"

    local dirty=$(git status -s)
    [ "$dirty" ] && err "You have uncommited changes. Please, commit them first"

    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    while (( $# )); do
        case $1 in
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name" "$help_msg"
                local base=$2
                [ ! "$(echo $branches | grep "$base")" ] && err "Branch [$base] doesn't exist:" "$(git branch)"
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number" "$help_msg"
                local issue=$2
                git config branch.$task.issue $issue
                ;;
            *)
                err "Wrong options: $*" "$help_msg" 
                ;;
        esac
        shift 2
    done
    local base=${base:-$(git config branch.$task.base)}
    base=${base:-master}
    local issue=${issue:-$(git config branch.$task.issue)}
    if [ ! "$issue" ]; then 
        red "Task is not connected to any issue."
        echo " Choose one of existing and use '-i <number>' option or create a new one"
        ghi list && exit 1
    fi
    local step1="`bold 1.` Try to merge `blue [$task]` into `green [$base]`"
    local step2="`bold 2.` Push `blue [$task]` branch"
    local step3="`bold 3.` Transform issue `yellow \#${issue}` into a pull-request"
    local step4="`bold 4.` Push `green [$base]` branch and timetracker notes (it will close issue `yellow \#${issue}`)"
    local step5="`bold 5.` Delete `blue [$task]` task and move the time remained on it to `green [$base]`"
    overview "$step1" "$step2" "$step3" "$step4" "$step5" 
    echo
    echo "$step1"
    git checkout $base
    git merge --no-ff $task
    failed $? "Couldn't merge branch [$task] into [$base]"
    echo
    echo "$step2"
    git push -u origin $task
    failed $? "Couldn't push [$task] branch to remote origin"
    echo
    echo "$step3"
    gtm_task_connect -t $task -b $base -i $issue
    failed $?
    echo
    echo "$step4"
    git push origin $base
    failed $? "Couldn't push [$base] branch to remote origin"
    git push
    failed $? "Couldn't push timetracker notes"
    echo
    echo "$step5"
    spent_set $(( $(spent_get) + $(git config branch.$task.spent) ))
    git branch -d $task
    failed $? "Couldn't delete branch [$task]"
    echo
    ghi show $issue
}

function gtm_task_switch() {
    local help_msg="
`bold Usage`: `blue 'gtm switch'` `green '<issue_number>'`

Switches to the task with given issue number (just does 'git checkout' to the corresponding branch)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    local issue=$1
    [ ! "$issue" ] && err "Choose task you want to switch to and use it's issue number or '-' for [master] branch:" "$(gtm_list)"
    [ "$issue" == "-" ] && git checkout master && exit

    local task=$(git config --get-regexp "branch.*.issue" | grep " $issue$")
    [ ! "$task" ] && err "No task #$issue. Create a new one or choose from existing:" "$(gtm_list)"
    local branch=${task%.issue*}
    git checkout ${branch#branch.}
}

function gtm_task_info() {
    local help_msg="
`bold Usage`: `blue 'gtm show'` `green '[-w]'`

Shows issue which is bound to the current task ('`green -w`' option works as in ghi: open issue in web-browser)
"
    case $1 in -h|--help) echo "$help_msg" && exit ;; esac

    echo "Task `blue "[$(current_branch)]"`: `gtm_status`" 
    echo
    local issue=$(git config branch.$(current_branch).issue)
    [ ! "$issue" ] && err "No issue is bound to the task. See 'gtm help connect'"
    [ "$1" == "-w" ] && web="-w"
    ghi show $issue $web
}

function gtm_addhooks() {
    [ ! "$(gitdir)" ] && err "It's not a git root directory!"
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    [ ! "$branches" ] && err "Looks like an empty repository. Make an init commit and try again."

    local hooksdir="$(gitdir)/hooks"
    [ ! -d $hooksdir ] && mkdir $hooksdir

    local pre_commit="$hooksdir/pre-commit"
    pre_commit_hook > $pre_commit
    chmod +x $pre_commit

    local post_commit="$hooksdir/post-commit"
    post_commit_hook > $post_commit
    chmod +x $post_commit

    local post_merge="$hooksdir/post-merge"
    post_merge_hook > $post_merge
    chmod +x $post_merge

    local post_checkout="$hooksdir/post-checkout"
    post_checkout_hook > $post_checkout
    chmod +x $post_checkout

    green "Hooks created: "
    echo "pre-commit, post-commit, post-merge, post-checkout"
}
function gtm_config() {
    local remote=${1:-origin}
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    [ ! "$branches" ] && err "Looks like an empty repository. Make an init commit and try again."

    local push="refs/notes/timetracker:refs/notes/timetracker"
    local exists=$(git config --get-all remote.$remote.push | grep "$push")
    [ ! "$exists" ] && git config --add remote.$remote.push $push

    local fetch="+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
    local exists=$(git config --get-all remote.$remote.fetch | grep "$fetch")
    [ ! "$exists" ] && git config --add remote.$remote.fetch $fetch

    git config notes.rewriteRef "refs/notes/timetracker"
    git config notes.displayRef "refs/notes/timetracker"
    git config timetracker.branch $(current_branch)

    for branch in $branches; do
        spent_get $branch &> /dev/null
    done

    green "Git task manager is configured. "
    echo "Now run 'git pull' and 'gtm merge' if you don't want problems"
}

#############

if (( $# == 0 )); then 
    [ ! $(gitdir) ] && show_help && exit 0
    gtm_status && exit 0
fi

subcommand=$1
shift

case $subcommand in
    stop|-p)
        gtm_stop "$@"
        exit 0
    ;;
    usage|-h|--help|help)
        show_help "$@"
        exit 0
    ;;
    version|-v|--version)
        echo "gtm v.$VERSION - git task/time manager (c) Alexey Alekhin"
        exit 0
    ;;
    prompt-status)
        if [ "$(git config timetracker.branch)" ]; then 
            on_status && human_time $(current_time) --short 
        else
            printf "%15s" $(date +%T)
        fi
        exit 0
    ;;
esac

if [ ! $(gitdir) ] && [ "$1" != "--help" ] && [ "$1" != "-h" ]; then
    err "It's not a git root directory!"
fi
case $subcommand in
    start)
        gtm_start "$@"
    ;;
    tmp)
		gtm_tmp "$@"
	;;
    status)
        gtm_status "$@"
    ;;
    set)
        gtm_set "$@"
        gtm_status
    ;;
    list)
        gtm_list "$@"
    ;;
    undo)
        gtm_undo "$@"
    ;;
    steal)
        gtm_steal "$@"
    ;;
    amend)
        gtm_amend "$@"
    ;;
    delete)
        git notes --ref timetracker remove ${1:-HEAD}
    ;;
    summary)
        gtm_summary "$@"
    ;;
    log)
        git log --color "$@" | sed "s/Time-spent: \([0-9]\+\)/gtm human-time \1/e" | less -R
    ;;
    timesince)
        current_date=$(date +%s)
        last=$(git log HEAD~${1:-0} -1 --format=%ct)
        t=$(( current_date - last ))
        gtm_set $(( $t / 60 ))
        gtm_status
    ;;
    human-time)
        human_time ${1:?"need time in seconds"}
    ;;
    addhooks)
        gtm_addhooks
    ;;
    config)
        gtm_config
    ;;
    init)
        gtm_addhooks
        gtm_config
    ;;
    merge)
        git notes --ref timetracker merge "refs/notes/remotes/${1:-origin}/timetracker"
    ;;
    push)
        gtm_push
    ;;
# Tasks:
    task)
        gtm_task_new "$@"
    ;;
    connect)
        gtm_task_connect "$@"
    ;;
    close)
        gtm_task_close "$@"
    ;;
    switch)
        gtm_task_switch "$@"
    ;;
    info)
        gtm_task_info "$@"
    ;;
    *)
        t=$(parse_time $subcommand) 
        if [[ ! $t =~ Wrong ]]; then
            gtm_set $subcommand
            gtm_status
        else
            red "Wrong subcommand: "; echo "$subcommand"
            show_help
        fi
    ;;
esac
