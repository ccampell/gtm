#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

# set -u

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

### USAGE

function show_help {
echo "
Usage: git timetrack command [options]

Current timer commands:
    start,     -s               start/continue counting time spent
    hacking,   -k               start/continue counting time spent, won't stop (only reset) on commit
    stop,      -p               stop/pause counting time spent
    reset,     -r               reset counting time spent
    add,       -g <[-]minutes>  add (or substract) time from the timer
    set,       -e    <minutes>  set time spent in minutes
    timesince, -ts              set time spent since last commit
    current,   -c               time spent currently in next commit

Commit related commands:
    ammend,  -a [<object>]  set currently spent time to last commit or to the given one
    delete,  -d [<object>]  delete time-spent to last commit or to the given one
    summary, -u [<opts>]    show summary of total time spent. takes similar options as 'git log'
    log,     -l [<opts>]    show git log with notes translates to human time

Configuration commands:
    addhooks           adds post-commit hook and post-merge to the project
    config [<remote>]  adds config to the project to pull and push timetrack info
    init               setup timetrack environment, hooks and config for origin
    merge  [<remote>]  merge timetracker notes from remote branch (origin by default)
"
}

### Depricated:
# Multiple timers commands:
#     save-timer,  -st <name>  save current timer to a named timer for later reuse
#     use-timer,   -ut <name>  sets an existent timer as current one
#     del-timer,   -dt <name>  delete an existent timer
#     timer-info,  -ti <name>  shows a timer information
#     list-timers, -lt         list existing timers

### HOOKS

function post_commit_hook() {
echo '#!/bin/bash

hacking=$(git config timetrack.hacking)
git timetrack stop # > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config timetrack.$current_branch.spent)
git timetrack reset

if [ $spent ]; then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $hacking ] && git timetrack start
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    git timetrack --merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

# if branch is switched
if (( $3 == 1 )); then
    old_branch=$(git config timetrack.branch)
    git timetrack timer-save $old_branch

    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git timetrack timer-use $current_branch

    git timetrack list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    s=${1:-0}
    m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    (( $h > 0 )) && printf "%2d hours" $h
    (( $m > 0 )) && printf " %2d minutes" $m
    (( $1 < 60 )) || (( $s > 0 )) && printf " %2d seconds\n" $s
}

function config_get() { 
    git config timetrack.$1
}
function config_set() {
    git config timetrack.$1 $2
}

function spent_get() { 
    spent=$(git config timetrack.$(config_get branch).spent)
    spent_set ${spent:-0}
    echo ${spent:-0}
}
function spent_set() {
    git config timetrack.$(config_get branch).spent $1
}

function current_branch() {
    git rev-parse --abbrev-ref HEAD
}

function current_time() {
    start_date=$(config_get start)
    current_date=$(date +%s)
    spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    alltimes=$(git log --author="$1" "${@:1}" | grep "Time-spent: " | cut -d":" -f2)

    total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

### SUBCOMMANDS

function gtt_start() {
    config_set start  $(date +%s)
    # config_set branch $(current_branch)
    gtt_timer_use $(current_branch)
}
function gtt_hacking() {
    gtt_start
    config_set hacking true
} 
function gtt_reset() {
    git config --unset timetrack.start
    git config --unset timetrack.$(current_branch).spent 2> /dev/null
}
function gtt_stop() {
    [ ! $(config_get start) ] && echo "nothing to stop"
    spent_set $(current_time)
    git config --unset timetrack.start
}
function gtt_current() {
    spent=$(current_time)
    if (( $spent == 0 )); then
        echo "timer is empty"
    else
        echo "time spent in next commit: $(human_time $spent)"
        [ $(config_get start) ]   && echo "timer counting" || echo "timer stopped"
        [ $(config_get hacking) ] && echo "hacking mode activated"
    fi
}
function gtt_list_timers() {
    timers=$(git config --get-regexp "timetrack\..*\.spent" | cut -d . -f 2 | sort -u)
    # count=0
    # echo "Saved timers:"
    width=15
    for timer in $timers; do
        (( ${#timer} > width )) && width=${#timer}
    done

    for timer in $timers; do
        # count=$(( $count + 1 ))
        spent=$(config_get $timer.spent)
        if [ "$timer" == "$(config_get branch)" ]
            then printf "* %-${width}s %31s *\n" "$timer" "$(human_time $(current_time))" 
            else printf "  %-${width}s %31s  \n" "$timer" "$(human_time $spent)" 
        fi
    done
    # printf "\n%s timers\n" "$count"
}
function gtt_set() {
    t=${1:?"argument needed"}
    gtt_reset
    config_set branch $(current_branch)
    spent_set $(( $t * 60 ))
}
function gtt_add() {
    t=${1:?"argument needed"}
    config_set branch $(current_branch)
    spent_set $(( $t * 60 + $(spent_get) ))
}
function gtt_timer_save() {
    config_set ${1:-$(config_get branch)}.spent $(current_time)
}
function gtt_timer_use() {
    t=${1:?"argument needed"}
    config_set branch $t
    spent_set $(spent_get)
}

function gtt_task_new() {
    name=$2
    [ -z "$name" ] && echo "need branch name for working on task"
    issue=$3

    prefix=${name%/*}
    labels=""
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    echo "This command will create"
    echo "- branch with name \"$name\""
    [ "$issue" ]  && echo "- github issue with name \"$issue\""
    [ "$labels" ] && echo "  and tags: ${labels// -L / }"
    read -p "Do you want to continue? [y/n]" ans
    [ "$ans" != "y" ] && exit 1

    config_set branch $(current_branch)
    git checkout -b $name
    git push -u origin $(current_branch)

    [ "$issue" ] && ghi open  --claim  -m "$issue" $labels "${@:4}"
    git commit -m "Created issue: "
}

#############

(( $# == 0 )) && show_help && exit 1

case $1 in
    start|-s|--start)
        gtt_start
        gtt_current
        ;;

    hacking|-k|--start-hacking)
        gtt_hacking
        gtt_current
        ;;

    stop|-p|--stop)
        gtt_stop
        gtt_current
        ;;

    current|-c|--current)
        gtt_current
        ;;

    reset|-r|--reset)
        gtt_reset
        ;;

    set|-e|--set)
        gtt_set "${@:2}"
        gtt_current
        ;;

    add|-g|--add)
        gtt_add "${@:2}"
        gtt_current
        ;;

    timer-save|-st|--save-timer)
        gtt_timer_save "${@:2}"
        ;;

    timer-use|-ut|--use-timer)
        gtt_timer_use "${@:2}"
        ;;

    timer-del|-dt|--del-timer)
        spent=$(config_get $2.spent)
        [ -z $spent ] && echo "timer $2 not found" && exit 1
        git config --remove-section timetrack.$2 2> /dev/null
        ;;

    info|-ti|--timer-info)
        spent=$(config_get $2.spent)
        [ -z $spent ] && echo "timer $2 not found" && exit 1
        echo "time spent in $2: $(human_time $spent)"
        ;;

    list|-lt|--list-timers)
        gtt_list_timers
        ;;

    ammend|-a|--amend)
        gtt_stop > /dev/null
        spent=$(spent_get)
        hacking=$(config_get hacking)
        gtt_reset

        [ $spent ] && git notes --ref timetracker add -f -m "Time-spent: $spent" $2
        [ $hacking ] && config_set start $(date +%s)
        ;;

    delete|-d|--delete)
        git notes --ref timetracker remove ${2:-HEAD}
        ;;

    summary|-u|--summary)
        shift
        allusers=$(git log --oneline --pretty="format:%ae" "${@:1}" | sort | uniq)
        alltimes=$(git log "${@:1}" | grep "Time-spent:"  | cut -d":" -f2)

        total=0
        for t in $alltimes; do
            total=$(( $total + $t ))
        done

        echo "total time spent by authors"
        for author in $allusers; do
            dedication=$(user_time_dedication "$author" "${@:1}")
            [ $dedication != 0 ] && printf " %-49s %s\n" "$author" "$(human_time $dedication)"
        done

        printf "\n%-50s %s\n" "total time spent in this project" "$(human_time $total)"
        printf "%-50s %s\n" "time spent in next comit" "$(human_time $(current_time))"

        [ $(config_get hacking) ] && echo "hacking mode activated"
        ;;

    log|-l|--log)
        git log --color "${@:2}" | sed "s/Time-spent: \([0-9]\+\)/git timetrack --human-time \1/e" | less -R
        ;;

    timesince|-ts|--timesince)
        current_date=$(date +%s)
        last=$(git log HEAD~${2:-0} -1 --format=%ct)
        t=$(( current_date - last ))
        gtt_set $(( $t / 60 ))
        gtt_current
        ;;

    # get-time|-gt|--get-time)
    #     t=$(git log ${2:-HEAD} -1 | grep "Time-spent:"  | cut -d":" -f2)
    #     [ -z $t ] && echo "Error, the specified commit does not have a Time-spent annotation" && exit 1
    #     gtt_set $t
    #     gtt_current
    #     ;;

    --human-time)
        echo $(human_time $2)
        ;;

    addhooks|-o|--addhooks)
        gitdir="$(git rev-parse --git-dir)"
        [ ! -d $gitdir ] && echo "It's not a git root directory. I won't do anything" && exit 1

    	hooksdir="$gitdir/hooks"
    	[ ! -d $hooksdir ] && mkdir $hooksdir

        post_commit="$hooksdir/post-commit"
        post_commit_hook > $post_commit
        chmod +x $post_commit

        post_merge="$hooksdir/post-merge"
        post_merge_hook > $post_merge
        chmod +x $post_merge

        post_checkout="$hooksdir/post-checkout"
        post_checkout_hook > $post_checkout
        chmod +x $post_checkout

        echo "hooks created"
        ;;

    config|-n|--config)
        remote=${2:-origin}
        git config --add remote.$remote.push "refs/notes/timetracker:refs/notes/timetracker"
        git config --add remote.$remote.fetch "+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
        git config notes.rewriteRef "refs/notes/timetracker"
        git config notes.displayRef "refs/notes/timetracker"
        config_set branch $(current_branch)

        echo "git timetrack configured. now run git pull if you don't want problems"
        ;;

    init|-i|--init)
        git timetrack --addhooks
        git timetrack --config
        ;;

    merge|-m|--merge)
        git notes --ref timetracker merge "refs/notes/remotes/${2:-origin}/timetracker"
        ;;

    task-new)
        gtt_task_new "${@:1}"
        ;;

    # task-report)
    #     gtt_task_report ${@:1}
    #     ;;

    *)
        show_help
        ;;
esac
