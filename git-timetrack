#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

# set -u

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

### USAGE

function show_help {
echo "
Usage: git timetrack command [options]

Current timer commands:
    start,     -s               start/continue counting time spent
    hacking,   -k               start/continue counting time spent, won't stop (only reset) on commit
    stop,      -p               stop/pause counting time spent
    reset,     -r               reset counting time spent
    add,       -g <[-]minutes>  add (or substract) time from the timer
    set,       -e    <minutes>  set time spent in minutes
    timesince, -ts              set time spent since last commit
    current,   -c               time spent currently in next commit

Commit related commands:
    ammend,  -a [<object>]  set currently spent time to last commit or to the given one
    delete,  -d [<object>]  delete time-spent to last commit or to the given one
    summary, -u [<opts>]    show summary of total time spent. takes similar options as 'git log'
    log,     -l [<opts>]    show git log with notes translates to human time

Configuration commands:
    addhooks           adds post-commit hook and post-merge to the project
    config [<remote>]  adds config to the project to pull and push timetrack info
    init               setup timetrack environment, hooks and config for origin
    merge  [<remote>]  merge timetracker notes from remote branch (origin by default)
"
}

### Depricated:
# Multiple timers commands:
#     save-timer,  -st <name>  save current timer to a named timer for later reuse
#     use-timer,   -ut <name>  sets an existent timer as current one
#     del-timer,   -dt <name>  delete an existent timer
#     timer-info,  -ti <name>  shows a timer information
#     list-timers, -lt         list existing timers

### HOOKS

function post_commit_hook() {
echo '#!/bin/bash

hacking=$(git config timetrack.hacking)
git timetrack stop # > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config timetrack.$current_branch.spent)
git timetrack reset

if [ $spent ]; then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $hacking ] && git timetrack start
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    git timetrack --merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

# if branch is switched
if (( $3 == 1 )); then
    old_branch=$(git config timetrack.branch)
    git timetrack timer-save $old_branch

    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git timetrack timer-use $current_branch

    git timetrack list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    s=${1:-0}
    m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    (( $h > 0 )) && printf "%2d hours" $h
    (( $m > 0 )) && printf " %2d minutes" $m
    (( $1 < 60 )) || (( $s > 0 )) && printf " %2d seconds\n" $s
}

function config_get() { 
    git config timetrack.$1
}
function config_set() {
    git config timetrack.$1 $2
}

function spent_get() { 
    branch=${1:-$(config_get branch)}
    spent=$(git config timetrack.$branch.spent)
    [ ! $spent ] && spent_set 0 $branch
    echo ${spent:-0}
}
function spent_set() {
    branch=${2:-$(config_get branch)}
    git config timetrack.$branch.spent $1
}

function current_branch() {
    git rev-parse --abbrev-ref HEAD
}

function current_time() {
    start_date=$(config_get start)
    current_date=$(date +%s)
    spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    alltimes=$(git log --author="$1" "${@:1}" | grep "Time-spent: " | cut -d":" -f2)

    total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

### SUBCOMMANDS

function gtt_start() {
    config_set start  $(date +%s)
    # config_set branch $(current_branch)
    gtt_timer_use $(current_branch)
}
function gtt_hacking() {
    gtt_start
    config_set hacking true
} 
function gtt_reset() {
    git config --unset timetrack.start
    git config --unset timetrack.$(current_branch).spent 2> /dev/null
}
function gtt_stop() {
    [ ! $(config_get start) ] && echo "nothing to stop"
    spent_set $(current_time)
    git config --unset timetrack.start
}
function gtt_current() {
    spent=$(current_time)
    if (( $spent == 0 )); then
        echo "timer is empty"
    else
        echo "time spent in next commit: $(human_time $spent)"
        [ $(config_get start) ]   && echo "timer counting" || echo "timer stopped"
        [ $(config_get hacking) ] && echo "hacking mode activated"
    fi
}
function gtt_list_timers() {
    timers=$(git config --get-regexp "timetrack\..*\.spent" | cut -d . -f 2 | sort -u)
    lwidth=10
    rwidth=0
    for timer in $timers; do
        (( ${#timer} > lwidth )) && lwidth=${#timer}
        spent=$(human_time $(config_get $timer.spent))
        (( ${#spent} > rwidth )) && rwidth=${#spent}
    done

    for timer in $timers; do
        spent=$(config_get $timer.spent)
        if [ "$timer" == "$(config_get branch)" ]
            then printf "* %-${lwidth}s %${rwidth}s *\n" "$timer" "$(human_time $(current_time))" 
            else printf "  %-${lwidth}s %${rwidth}s  \n" "$timer" "$(human_time $spent)" 
        fi
    done
}
function gtt_set() {
    t=${1:?"time amount needed"}
    gtt_reset
    config_set branch $(current_branch)
    spent_set $(( $t * 60 ))
}
function gtt_add() {
    t=${1:?"time amount needed"}
    config_set branch $(current_branch)
    spent_set $(( $t * 60 + $(spent_get) ))
}
function gtt_timer_save() {
    config_set ${1:-$(config_get branch)}.spent $(current_time)
}
function gtt_timer_use() {
    t=${1:?"timer name needed"}
    config_set branch $t
    spent_set $(spent_get)
}
function gtt_timer_delete() {
    for timer in "$@"; do
        spent=$(config_get $timer.spent)
        [ -z $spent ] && echo "timer $timer not found" && exit 1
        git config --remove-section timetrack.$timer 2> /dev/null
    done
}
function gtt_timer_info() {
    for timer in "$@"; do
        spent=$(config_get $timer.spent)
        [ -z $spent ] && echo "timer $timer not found" && exit 1
        echo "time spent in $timer: $(human_time $spent)"
    done
}

function gtt_task_new() {
    name=${1:?"need a branch name for working on task"}
    issue_flag=$2
    # [ "$2" != "-m" ] && [ "$2" != "-i" ] && show_help && exit 1
    issue=$3

    prefix=${name%/*}
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    # info and confirmation
    echo "This command will create"
    echo "- local branch with name \"$name\""
    case $issue_flag in
        -m)
            echo "- github issue with name \"$issue\""
            [ $labels ] && echo "  and tags: ${prefix//\//, }"
        ;;
        -i)
            echo "And bind it to the issue:"
            ghi show $issue
        ;;
    esac
    read -p "Do you want to continue? [y/n]" ans
    [ "$ans" != "y" ] && exit 1

    # branch creating
    config_set branch $(current_branch)
    git checkout -b $name

    # issue binding
    case $issue_flag in
        -m)
            ghi_out=$(ghi open  --claim  -m "$issue" $labels "${@:3}")
            echo
            echo "$ghi_out"
            for line in $ghi_out; do
                number=$(expr $line : '^#\([0-9]*\):')
                [ "$number" ] && config_set $name.issue $number && break
            done
        ;;
        -i)
            config_set $name.issue $issue
        ;;
    esac
}
function gtt_task_delete() {
    for task in "$@"; do
        not_merged=$(git branch --no-merged | grep "^ *$task$")
        [ "$not_merged" ] && echo "Looks like branch \"$task\" is not merged"
        read -p "Are you sure you want to delete it? [y/n]" ans
        [ "$ans" != "y" ] && exit 1

        git branch -d $task
        gtt_timer_delete $task
    done
}
function gtt_task_connect() {
    branch=$(config_get branch)
    issue=${1:-$(config_get $branch.issue)}
    [ -z "$issue" ] && echo "need issue number" && exit 1

    # check if the branch has upstream
    git rev-parse --abbrev-ref $branch@{upstream} &> /dev/null
    u=$( (( $? != 0 )) && echo "-u" )
    git push "$u" origin $branch

    echo
    ghi edit --head $branch $issue
    config_set $branch.issue $issue
}


#############

(( $# == 0 )) && show_help && exit 1

subcommand=$1
shift && args="$@"

case $subcommand in
    start|-s)
        gtt_start
        gtt_current
    ;;
    hacking|-k)
        gtt_hacking
        gtt_current
    ;;
    stop|-p)
        gtt_stop
        gtt_current
    ;;
    current|-c)
        gtt_current
    ;;
    reset|-r)
        gtt_reset
    ;;
    set|-e)
        gtt_set $args
        gtt_current
    ;;
    add|-g)
        gtt_add $args
        gtt_current
    ;;
    timer-save)
        gtt_timer_save $args
    ;;
    timer-use)
        gtt_timer_use $args
    ;;
    timer-delete)
        gtt_timer_delete $args
    ;;
    timer-info)
        gtt_timer_info $args
    ;;
    list)
        gtt_list_timers
    ;;
    ammend|-a)
        sha=${1:?"need commit sha"}
        gtt_stop > /dev/null
        spent=$(spent_get)
        hacking=$(config_get hacking)
        gtt_reset

        [ $spent ] && git notes --ref timetracker add -f -m "Time-spent: $spent" $sha
        [ $hacking ] && config_set start $(date +%s)
    ;;
    delete|-d)
        git notes --ref timetracker remove ${1:-HEAD}
    ;;
    summary|-u)
        shift
        allusers=$(git log --oneline --pretty="format:%ae" $args | sort | uniq)
        alltimes=$(git log $args | grep "Time-spent:"  | cut -d":" -f2)

        total=0
        for t in $alltimes; do
            total=$(( $total + $t ))
        done

        echo "total time spent by authors"
        for author in $allusers; do
            dedication=$(user_time_dedication "$author" $args)
            [ $dedication != 0 ] && printf " %-49s %s\n" "$author" "$(human_time $dedication)"
        done

        printf "\n%-50s %s\n" "total time spent in this project" "$(human_time $total)"
        printf "%-50s %s\n" "time spent in next comit" "$(human_time $(current_time))"

        [ $(config_get hacking) ] && echo "hacking mode activated"
    ;;
    log)
        git log --color $args | sed "s/Time-spent: \([0-9]\+\)/git timetrack human-time \1/e" | less -R
    ;;
    timesince)
        current_date=$(date +%s)
        last=$(git log HEAD~${1:-0} -1 --format=%ct)
        t=$(( current_date - last ))
        gtt_set $(( $t / 60 ))
        gtt_current
    ;;
    human-time)
        human_time ${1:?"need time in seconds"}
    ;;
    addhooks)
        gitdir="$(git rev-parse --git-dir)"
        [ ! -d $gitdir ] && echo "It's not a git root directory. I won't do anything" && exit 1

    	hooksdir="$gitdir/hooks"
    	[ ! -d $hooksdir ] && mkdir $hooksdir

        post_commit="$hooksdir/post-commit"
        post_commit_hook > $post_commit
        chmod +x $post_commit

        post_merge="$hooksdir/post-merge"
        post_merge_hook > $post_merge
        chmod +x $post_merge

        post_checkout="$hooksdir/post-checkout"
        post_checkout_hook > $post_checkout
        chmod +x $post_checkout

        echo "hooks created"
    ;;
    config)
        remote=${1:-origin}
        git config --add remote.$remote.push "refs/notes/timetracker:refs/notes/timetracker"
        git config --add remote.$remote.fetch "+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
        git config notes.rewriteRef "refs/notes/timetracker"
        git config notes.displayRef "refs/notes/timetracker"
        config_set branch $(current_branch)

        branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
        for branch in $branches; do
            spent_get $branch &> /dev/null
        done

        echo "git timetrack configured. now run git pull if you don't want problems"
    ;;
    init)
        git timetrack addhooks
        git timetrack config
    ;;
    merge)
        git notesref timetracker merge "refs/notes/remotes/${1:-origin}/timetracker"
    ;;
    task-new)
        gtt_task_new $args
    ;;
    task-delete)
        gtt_task_delete $args
    ;;
    task-connect)
        gtt_task_connect $args
    ;;
    *)
        show_help
    ;;
esac
