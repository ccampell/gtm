#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

# set -u

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

# Text color variables
tund=$(tput sgr 0 1) # underline
tbld=$(tput bold)    # bold
tred=$(tput setaf 88) # red
tgrn=$(tput setaf 28) # green
tyel=$(tput setaf 3) # yellow
tblu=$(tput setaf 32) # blue
tgry=$(tput setaf 8) # gray
trst=$(tput sgr0)    # reset
# Surroungings
txtsurround() {
    printf "${1}${2}${trst}" "${@:3}"
}
txtred() {
    txtsurround $tred "$@"
}
txtgreen() {
    txtsurround $tgrn "$@"
}
txtyellow() {
    txtsurround $tyel "$@"
}
txtblue() {
    txtsurround $tblu "$@"
}
txtgray() {
    txtsurround $tgry "$@"
}
txtbold() {
    txtsurround $tbld "$@"
}
txt_() {
    txtsurround $tund "$@"
}

err() {
    txtred "$1\n" && exit 1
}


### USAGE

function show_help {
echo "
Usage: git timetrack command [options]

Current timer commands:
    start,     -s               start/continue counting time spent
    hacking,   -k               start/continue counting time spent, won't stop (only reset) on commit
    stop,      -p               stop/pause counting time spent
    reset,     -r               reset counting time spent
    add,       -g <[-]minutes>  add (or substract) time from the timer
    set,       -e    <minutes>  set time spent in minutes
    timesince, -ts              set time spent since last commit
    current,   -c               time spent currently in next commit

Commit related commands:
    ammend,  -a [<object>]  set currently spent time to last commit or to the given one
    delete,  -d [<object>]  delete time-spent to last commit or to the given one
    summary, -u [<opts>]    show summary of total time spent. takes similar options as 'git log'
    log,     -l [<opts>]    show git log with notes translates to human time

Configuration commands:
    addhooks           adds post-commit hook and post-merge to the project
    config [<remote>]  adds config to the project to pull and push timetrack info
    init               setup timetrack environment, hooks and config for origin
    merge  [<remote>]  merge timetracker notes from remote branch (origin by default)
"
}

### HOOKS

function post_commit_hook() {
echo '#!/bin/bash

hacking=$(git config timetrack.hacking)
git-timetrack stop > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config branch.$current_branch.spent)
git-timetrack reset

if [ $spent ]; then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $hacking ] && git-timetrack start > /dev/null
    echo "Time-spent: $(git-timetrack human-time $spent)"
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    git-timetrack merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

if (( $3 == 1 )) # if branch is switched
then
    # save state of old branch
    old_branch=$(git config timetrack.branch)
    start=$(git config timetrack.start)
    spent=$(git config branch.$old_branch.spent)
    now=$(date +%s)

    [ $start ] && spent=$(( $spent + $now - $start ))
    git config branch.$old_branch.spent $spent
    git config --unset timetrack.start

    # use new branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git config timetrack.branch $current_branch
    [ "$start" ] && git-timetrack start &> /dev/null

    git-timetrack list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    s=${1:-0}
    m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    if [ "$2" == "--short" ]; then
        (( $h < 10 )) && hh=" $h:" || hh="$h:"
        # (( $h == 0 )) && hh="    "
        (( $m < 10 )) && mm="0$m:" || mm="$m:"
        # (( $m == 0 )) && mm="    "
        (( $s < 10 )) && ss="0$s" || ss="$s"
        echo " $hh$mm$ss"
    else 
        (( $h >  0 )) && printf "%2d hours "    $h
        (( $m >  0 )) && printf "%2d minutes "  $m
        (( $s >= 0 )) && printf "%2d seconds\n" $s
    fi
}

function config_get() { 
    git config timetrack.$1
}
function config_set() {
    git config timetrack.$1 $2
}

function spent_get() { 
    branch=${1:-$(current_branch)}
    spent=$(git config branch.$branch.spent)
    [ ! $spent ] && git config branch.$branch.spent 0
    echo ${spent:-0}
}
function spent_set() {
    branch=${2:-$(current_branch)}
    git config branch.$branch.spent $1
}

function current_branch() {
    git rev-parse --abbrev-ref HEAD
}

function current_time() {
    start_date=$(config_get start)
    current_date=$(date +%s)
    spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    alltimes=$(git log --author="$1" --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')

    total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

function on_status() {
    [ $(config_get start) ] && txtgreen "  [on]" || txtred " [off]"
}
function mode_status() {
    [ $(config_get hacking) ] && txtblue " [non-stop]"
}
### SUBCOMMANDS

function gtt_start() {
    config_set start $(date +%s)
    spent_get &> /dev/null
}
function gtt_hacking() {
    gtt_start
    config_set hacking true
} 
function gtt_reset() {
    git config --unset timetrack.start
    git config --unset branch.$(current_branch).spent
}
function gtt_stop() {
    # [ ! $(config_get start) ] && err "Nothing to stop"
    spent_set $(current_time)
    git config --unset timetrack.start
}
function gtt_current() {
    spent=$(current_time)
    [ "$1" == "-s" ] && echo $spent && exit 0

    # if (( $spent == 0 )); then
    #     echo "Timer is empty"
    # else
        echo -n "$(human_time $spent)"
        on_status && mode_status
        echo
    # fi
}
function gtt_list() {
    branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    current_branch=$(current_branch)
    [ $(config_get start) ] && gtt_stop && gtt_start
    lwidth=10
    rwidth=0
    for branch in $branches; do
        (( ${#branch} > lwidth )) && lwidth=${#branch}
        spent=$(human_time $(git config branch.$branch.spent))
        (( ${#spent} > rwidth )) && rwidth=${#spent}
    done

    txt_ "  #  %-${lwidth}s %${rwidth}s \n" "Task" "Time spent"
    for branch in $branches; do
        spent=$(human_time $(git config branch.$branch.spent))
        issue=$(git config branch.$branch.issue)
        if [ "$branch" == "$current_branch" ]
        then 
            printf "* "
            txtyellow "%-2s " "$issue" 
            printf "%-${lwidth}s " "$branch" 
            printf  "%${rwidth}s"  "$spent"
            on_status && mode_status
        else 
            txtyellow "  %-2s " "$issue" 
            printf "%-${lwidth}s " "$branch" 
            printf  "%${rwidth}s"  "$spent"
        fi
        echo
    done
}
function gtt_summary() {
    alltimes=$(git log --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    allusers=$(git log --format="%ae" | sort | uniq)
    commits=$((`git log --oneline | wc -l`))
    timed_commits=$((`git log --format="%N"  | grep "Time-spent:" | wc -l`))
    percent=$(( $timed_commits * 100 / $commits ))
    echo "$timed_commits of $commits commits have time information ($percent%)"

    echo -n "Total time spent by authors in branch "
    txtblue "[$(current_branch)]\n"
    for author in $allusers; do
        dedication=$(user_time_dedication $author)
        [ $dedication != 0 ] && printf " %-39s %s\n" "$author" "$(human_time $dedication)"
    done

    total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done
    printf "\n%-40s %s\n" "Total time spent in this branch" "$(human_time $total)"
}

function gtt_set() {
    t=${1:?"time amount needed"}
    gtt_reset
    spent_set $(( $t * 60 ))
}
function gtt_add() {
    t=${1:?"time amount needed"}
    spent_set $(( $t * 60 + $(spent_get) ))
}
function gtt_timer_info() {
    for timer in "$@"; do
        spent=$(git config branch.$timer.spent)
        [ -z $spent ] && echo "timer $timer not found" && exit 1
        echo "Time spent in $timer: $(human_time $spent)"
    done
}

function gtt_task_new() {
    name=${1:?"need a branch name for working on task"}
    issue_flag=$2
    # [ "$2" != "-m" ] && [ "$2" != "-i" ] && show_help && exit 1
    issue=$3

    prefix=${name%/*}
    labels=""
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    # info and confirmation
    echo "This command will create"
    echo -n "- local branch with name "; txtblue "[$name]\n"
    case $issue_flag in
        -m)
            echo -n "- github issue with name "; txtyellow "\"$issue\"\n"
            [ "$labels" ] && echo "  and tags: ${prefix//\//, }"
        ;;
        -i)
            echo "And bind it to the issue:"
            ghi show $issue
        ;;
    esac
    read -p "Do you want to continue? [y/n]" ans
    [ "$ans" != "y" ] && exit 1

    git checkout -b $name

    # issue binding
    case $issue_flag in
        -m)
            ghi_out=$(ghi open  --claim  -m "$issue" $labels "${@:3}")
            echo
            echo "$ghi_out"
            for line in $ghi_out; do
                number=$(expr $line : '^#\([0-9]*\):')
                [ "$number" ] && git config branch.$name.issue $number && break
            done
        ;;
        -i)
            git config branch.$name.issue $issue
        ;;
    esac
}
function gtt_task_connect() {
    branch=$(current_branch)
    issue=${1:-$(git config branch.$branch.issue)}
    [ -z "$issue" ] && err "Need issue number"

    # check if the branch has upstream
    git rev-parse --abbrev-ref $branch@{upstream} &> /dev/null
    u=$( (( $? != 0 )) && echo "-u" )
    git push "$u" origin $branch

    echo
    ghi edit --head $branch $issue
    git config branch.$branch.issue $issue
}
function gtt_task_close() {
    branch=$(current_branch)
    [ "$branch" == "master" ] && err "You are on [master] branch. Swith to the task, that you want to close"

    dirty=$(git status -s)
    [ "$dirty" ] && err "You have uncommited changes. Please, commit them before"

    while (( $# )); do
        case $1 in
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name"
                base=$2
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number"
                issue=$2
                git config branch.$branch.issue $issue
                ;;
            *)
                err "Wrong options"
                ;;
        esac
        shift 2
    done
    base=${base:-master}
    issue=${issue:-$(git config branch.$branch.issue)}
    if [ ! "$issue" ]; then 
        txtred "Task is not connected to any issue."
        echo " Choose one of existing and use '-i <number>' option or create a new one"
        ghi list
        exit 1
    fi

    echo "This command will"
    echo "1. `txt_ push` `txtblue [$branch]` branch"
    echo "2. make a `txt_ pull-request` from the issue `txtyellow \#${issue}`"
    echo "3. `txt_ switch` to the `txtgreen [$base]` branch"
    echo "4. `txt_ merge` `txtblue [$branch]` into `txtgreen [$base]`"
    echo "5. `txt_ push` `txtgreen [$base]` branch and timetracker notes"
    echo "   (it will `txt_ close` connected issue `txtyellow \#${issue}`)"
    echo "6. `txt_ delete` `txtblue [$branch]` task"

    read -p "Do you want to continue? [y/n]" ans
    [ "$ans" != "y" ] && exit 1

    gtt_task_connect $issue
    git checkout $base
    git merge --no-ff $branch
    git push origin $base && git push
    git branch -d $branch
    ghi show $issue
}


#############

(( $# == 0 )) && gtt_current && exit 0

subcommand=$1
shift

case $subcommand in
    start|-s)
        gtt_start
        gtt_current
    ;;
    hacking|-k)
        gtt_hacking
        gtt_current
    ;;
    stop|-p)
        gtt_stop
        gtt_current
    ;;
    current|-c)
        gtt_current "$@"
    ;;
    reset|-r)
        gtt_reset
    ;;
    set|-e)
        gtt_set "$@"
        gtt_current
    ;;
    add|-g)
        gtt_add "$@"
        gtt_current
    ;;
    timer-info)
        gtt_timer_info "$@"
    ;;
    list)
        gtt_list
    ;;
    ammend|-a)
        sha=${1:?"need commit sha"}
        gtt_stop
        spent=$(spent_get)
        hacking=$(config_get hacking)
        gtt_reset

        if [ $spent ]; then 
            git notes --ref timetracker add -f -m "Time-spent: $spent" $sha
            echo "Time spent: $(human_time $spent)"
        fi
        [ $hacking ] && config_set start $(date +%s)
    ;;
    delete|-d)
        git notes --ref timetracker remove ${1:-HEAD}
    ;;
    summary|-u)
        gtt_summary "$@"
    ;;
    log)
        git log --color "$@" | sed "s/Time-spent: \([0-9]\+\)/git timetrack human-time \1/e" | less -R
    ;;
    timesince)
        current_date=$(date +%s)
        last=$(git log HEAD~${1:-0} -1 --format=%ct)
        t=$(( current_date - last ))
        gtt_set $(( $t / 60 ))
        gtt_current
    ;;
    human-time)
        human_time ${1:?"need time in seconds"}
    ;;
    addhooks)
        gitdir="$(git rev-parse --git-dir)"
        [ ! -d $gitdir ] && err "It's not a git root directory!"

    	hooksdir="$gitdir/hooks"
    	[ ! -d $hooksdir ] && mkdir $hooksdir

        post_commit="$hooksdir/post-commit"
        post_commit_hook > $post_commit
        chmod +x $post_commit

        post_merge="$hooksdir/post-merge"
        post_merge_hook > $post_merge
        chmod +x $post_merge

        post_checkout="$hooksdir/post-checkout"
        post_checkout_hook > $post_checkout
        chmod +x $post_checkout

        txtgreen "Hooks created: "
        echo "post-commit, post-merge, post-checkout"
    ;;
    config)
        remote=${1:-origin}
        git config --add remote.$remote.push "refs/notes/timetracker:refs/notes/timetracker"
        git config --add remote.$remote.fetch "+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
        git config notes.rewriteRef "refs/notes/timetracker"
        git config notes.displayRef "refs/notes/timetracker"
        config_set branch $(current_branch)

        branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
        for branch in $branches; do
            spent_get $branch &> /dev/null
            # spent_set $(spent_get $branch) $branch
        done

        txtgreen "Git timetrack is configured. "
        echo "Now run git pull if you don't want problems"
    ;;
    init)
        git timetrack addhooks
        git timetrack config
    ;;
    merge)
        git notes --ref timetracker merge "refs/notes/remotes/${1:-origin}/timetracker"
    ;;
    task-new)
        gtt_task_new "$@"
    ;;
    task-connect)
        gtt_task_connect "$@"
    ;;
    task-close)
        gtt_task_close "$@"
    ;;
    prompt-status)
        if [ "$(git config timetrack.branch)" ]; then 
            on_status && human_time $(current_time) --short 
        else
            txtgray "%15s" $(date +%T)
        fi
    ;;
    usage|-h|--help|help)
        show_help
    ;;
    *)
        txtred "Wrong subcommand: "; echo "$subcommand"
        show_help
    ;;
esac
