#!/bin/bash

# Copyright (C) 2010 Daniel Garcia Moreno <dani@danigm.net>
# Copyright (C) 2010 Eduardo Robles Elvira <edulix@wadobo.com>
# Copyright (C) 2013 Alexey Alekhin <alexey.alekhin@me.com>
#
# This software may be used and distributed according to the terms of the
# GNU General Public License version 3 or any later version, incorporated
# herein by reference.

# set -u

export GIT_NOTES_DISPLAY_REF="refs/notes/timetracker"

# Text color variables
tund=$(tput sgr 0 1) # underline
tbld=$(tput bold)    # bold
tred=$(tput setaf 1) # red
tgrn=$(tput setaf 2) # green
tyel=$(tput setaf 3) # yellow
tblu=$(tput setaf 4) # blue
tgry=$(tput setaf 8) # gray
trst=$(tput sgr0)    # reset
# Surroungings
txtsurround() {
    printf "${1}${2}${trst}" "${@:3}"
}
txtred() {
    txtsurround $tred "$@"
}
txtgreen() {
    txtsurround $tgrn "$@"
}
txtyellow() {
    txtsurround $tyel "$@"
}
txtblue() {
    txtsurround $tblu "$@"
}
txtgray() {
    txtsurround $tgry "$@"
}
txtbold() {
    txtsurround $tbld "$@"
}
txt_() {
    txtsurround $tund "$@"
}

err() {
    txtred "$1\n" && exit 1
}
confirm() {
    echo "$1"
    read -n 1 -p "`txtgray "[press any key to continue]"`"
    # now go up one line and erase it
    tput cuu1 && tput el
    echo
}
overview() {
    echo `txtbold "Operation overview:"`
    for s in "$@"; do
        echo $s
    done
    read -n 1 -p "`txtgray "[review steps and press any key to continue]"`"
    local n=$(( $# + 2 ))
    until (( n == 0 )); do
        tput cuu1 && tput el
        n=$(( n - 1 ))
    done
}
failed() {
    local result=$1
    local msg=${2:-"Previous step has failed"}
    if (( $result != 0 )); then
        echo `txtred "$msg"`
        read -n 1 -p "`txtgray "[press Ctrl-C to stop or any other key to continue]"`"
        tput cuu1 && tput el
        echo
    fi
}

### USAGE

function show_help {
echo "
Usage: git timetrack command [options]

Current timer commands:
    start,     -s               start/continue counting time spent
    stop,      -p               stop/pause counting time spent
    reset,     -r               reset counting time spent
    add,       -g <[-]minutes>  add (or substract) time from the timer
    set,       -e    <minutes>  set time spent in minutes
    timesince, -ts              set time spent since last commit
    current,   -c               time spent currently in next commit

Commit related commands:
    ammend,  -a [<object>]  set currently spent time to last commit or to the given one
    delete,  -d [<object>]  delete time-spent to last commit or to the given one
    summary, -u [<opts>]    show summary of total time spent. takes similar options as 'git log'
    log,     -l [<opts>]    show git log with notes translates to human time

Configuration commands:
    addhooks           adds post-commit hook and post-merge to the project
    config [<remote>]  adds config to the project to pull and push timetrack info
    init               setup timetrack environment, hooks and config for origin
    merge  [<remote>]  merge timetracker notes from remote branch (origin by default)
"
}

### HOOKS

function pre_commit_hook() {
echo '#!/bin/bash
# check if the timer is not zero
time=$(git-timetrack current --seconds)
if (( $time == 0 )); then
    echo "`tput setaf 1`You forgot to set the timer!`tput sgr0`"
    exit 1
fi
'
}


function post_commit_hook() {
echo '#!/bin/bash

running=$(git config timetrack.start)
git-timetrack stop > /dev/null
current_branch=$(git rev-parse --abbrev-ref HEAD)
spent=$(git config branch.$current_branch.spent)
git config --unset branch.$current_branch.spent

if (( ${spent:-0} > 0 )); then
    git notes --ref timetracker add -m "Time-spent: $spent"
    [ $running ] && git-timetrack start > /dev/null
    echo "Time-spent: $(git-timetrack human-time $spent)"
fi'
}

function post_merge_hook() {
echo '#!/bin/bash

gitdir=$(git rev-parse --git-dir)
for remote in $gitdir/refs/notes/remotes/*; do
    git-timetrack merge "$(basename $remote)"
done'
}

function post_checkout_hook() {
echo '#!/bin/bash

if (( $3 == 1 )) # if branch is switched
then
    old_branch=$(git config timetrack.branch)
    start=$(git config timetrack.start)
    spent=$(git config branch.$old_branch.spent)
    now=$(date +%s)

    # save state of old branch
    [ $start ] && spent=$(( $spent + $now - $start ))
    git config branch.$old_branch.spent ${spent:-0}
    git config --unset timetrack.start

    # use new branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    git config timetrack.branch $current_branch
    [ "$start" ] && git-timetrack start &> /dev/null

    git-timetrack list
fi'
}

### COMMON FUNCTIONS

function human_time() {
    local s=${1:-0}
    local m=0
    while (( $s >= 60 )); do
        m=$(( $m + $s / 60 ))
        s=$(( $s % 60 ))
    done
    local h=0
    while (( $m >= 60 )); do
        h=$(( $h + $m / 60 ))
        m=$(( $m % 60 ))
    done

    if [ "$2" == "--short" ]; then
        (( $h < 10 )) && hh=" $h:" || hh="$h:"
        # (( $h == 0 )) && hh="    "
        (( $m < 10 )) && mm="0$m:" || mm="$m:"
        # (( $m == 0 )) && mm="    "
        (( $s < 10 )) && ss="0$s" || ss="$s"
        echo " $hh$mm$ss"
    else 
        (( $h >  0 )) && printf "%2d hours "    $h
        (( $m >  0 )) && printf "%2d minutes "  $m
        (( $s >= 0 )) && printf "%2d seconds\n" $s
    fi
}

function config_get() { 
    git config timetrack.$1
}
function config_set() {
    git config timetrack.$1 $2
}

function spent_get() { 
    local branch=${1:-$(current_branch)}
    local spent=$(git config branch.$branch.spent)
    [ ! $spent ] && git config branch.$branch.spent 0
    echo ${spent:-0}
}
function spent_set() {
    local branch=${2:-$(current_branch)}
    git config branch.$branch.spent $1
}

function current_branch() {
    git rev-parse --abbrev-ref HEAD
}

function current_time() {
    local start_date=$(config_get start)
    local current_date=$(date +%s)
    local spent=$(spent_get)
    [ $start_date ] && spent=$(( $spent + $current_date - $start_date ))
    echo $spent
}

function user_time_dedication() {
    local alltimes=$(git log --author="$1" --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done

    echo $total
}

function running() {
    echo "$(git config timetrack.start)"
}

function on_status() {
    [ $(config_get start) ] && txtgreen "  [on]" || txtred " [off]"
}

function gitdir() {
    echo "$(git rev-parse --git-dir 2> /dev/null)"
}
### SUBCOMMANDS

function gtt_start() {
    [ ! $(gitdir) ] && err "It's not a git root directory!"

    local current_repo=$(git config --global timetrack.repo)
    local current_dir=$(pwd -P)
    if [ "$current_repo" == "$current_dir" ] && [ $(running) ]; then
        gtt_current
    else
        [ "$current_repo" ] && [ "$current_repo" != "$current_dir" ] && gtt_stop
        config_set start $(date +%s)
        spent_get > /dev/null
        git config --global timetrack.repo $current_dir
        echo "`gtt_current --no-status` `txtgreen [started]`"
    fi
}
function gtt_reset() {
    git config --unset timetrack.start
    git config --unset branch.$(current_branch).spent
}

function gtt_stop() {
    local current_repo=$(git config --global timetrack.repo)
    if [ ! "$current_repo" ]; then
        [ ! $(gitdir) ] && err "No running timers"
        gtt_current
    else
        local current_dir=$(pwd -P)
        [ "$current_repo" != "$current_dir" ] && cd $current_repo
        spent_set $(current_time)
        git config --unset timetrack.start

        printf "`gtt_current --no-status` `txtred [paused]`"
        [ "$current_repo" != "$current_dir" ] && echo " in `txtblue [$current_repo]`" || echo

        [ "$current_repo" != "$current_dir" ] && cd $current_dir
        git config --global --remove-section timetrack &> /dev/null
    fi
}

function gtt_current() {
    local spent=$(current_time)
    [ "$1" == "--seconds" ] && echo $spent && exit 0
    local current_dir=$(pwd -P)
    if [ "$1" == "--global" ]; then
        local current_repo=$(git config --global timetrack.repo)
        if [ "$current_repo" != "$current_dir" ]; then
            cd ${current_repo:-.}
            echo -n "`pwd`: "; txtblue "[`current_branch`] "
        fi
    fi
    echo -n "$(human_time $spent)"
    [ "$1" != "--no-status" ] && echo "`on_status`"
    [ "$current_repo" ] && cd $current_dir
}
function gtt_list() {
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local current_branch=$(current_branch)
    [ $(config_get start) ] && gtt_stop > /dev/null && gtt_start > /dev/null
    local lwidth=10
    local rwidth=0
    for branch in $branches; do
        (( ${#branch} > lwidth )) && lwidth=${#branch}
        local spent=$(human_time $(git config branch.$branch.spent))
        (( ${#spent} > rwidth )) && rwidth=${#spent}
    done
    lwidth=$(( lwidth + 2 )) # for [...]

    txt_ "$(txtbold "  #  %-${lwidth}s %${rwidth}s \n" "Task" "Time spent")"
    for branch in $branches; do
        local spent=$(human_time $(git config branch.$branch.spent))
        local issue=$(git config branch.$branch.issue)
        if [ "$branch" == "$current_branch" ]
        then 
            [ $(config_get start) ] && txtgreen "* " || txtred "* "
            txtyellow "%-2s " "$issue" 
            txtblue "%-${lwidth}s " "[$branch]" 
            printf  "%${rwidth}s"  "$spent"
            on_status
        else 
            txtyellow "  %-2s " "$issue" 
            txtblue "%-${lwidth}s " "[$branch]" 
            printf  "%${rwidth}s"  "$spent"
        fi
        echo
    done
}
function gtt_summary() {
    local alltimes=$(git log --format="%N"  | grep "Time-spent:" | sed 's/ *Time-spent: *//')
    local allusers=$(git log --format="%ae" | sort | uniq)
    local commits=$((`git log --oneline | wc -l`))
    local timed_commits=$((`git log --format="%N"  | grep "Time-spent:" | wc -l`))
    local percent=$(( $timed_commits * 100 / $commits ))
    echo "$timed_commits of $commits commits have time information ($percent%)"

    echo -n "Total time spent by authors in branch "
    txtblue "[$(current_branch)]\n"
    for author in $allusers; do
        local dedication=$(user_time_dedication $author)
        [ $dedication != 0 ] && printf " %-39s %s\n" "$author" "$(human_time $dedication)"
    done

    local total=0
    for t in $alltimes; do
        total=$(( $total + $t ))
    done
    printf "\n%-40s %s\n" "Total time spent in this branch" "$(human_time $total)"
}

function gtt_set() {
    local t=${1:?"time amount needed"}
    gtt_reset
    spent_set $(( $t * 60 ))
}
function gtt_add() {
    local t=${1:?"time amount needed"}
    spent_set $(( $t * 60 + $(spent_get) ))
}

function gtt_task_new() {
    local name=$1
    [ ! "$name" ] && err "Need a branch name for creating task (use '-' for current branch)"
    [ "$name" == "-" ] && name=$(current_branch)

    local issue_flag=$2
    [ "$issue_flag" != "-i" ] && [ "$issue_flag" != "-m" ] && err "Wrong option: $issue_flag"
    local issue=$3

    local prefix=${name%/*}
    local labels=""
    # if prefix was not empty
    [ "$prefix" != "$name" ] && labels=" -L "${prefix//\// -L }

    # info and confirmation
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    local exists=$(echo $branches | grep "$name")
    if [ "$exists" ]; then
        local step1="`txtbold 1.` Use an existing branch `txtblue [$name]`"
    else
        local step1="`txtbold 1.` Create a new branch `txtblue [$name]`"
    fi
    case $issue_flag in
        -i)
            local step2="`txtbold 2.` Bind the task to an existing issue `txtyellow \#$issue`:"
        ;;
        -m)
            local step2="`txtbold 2.` Bind the task to a new issue "$(txtyellow "\"$issue\"")
            [ "$labels" ] && step2=$step2" with tags: ${prefix//\//, }"
        ;;
    esac
    echo $step1
    echo $step2
    [ "$issue_flag" == "-i" ] && ghi show $issue
    confirm

    [ ! "$exists" ] && git checkout -b $name

    # issue binding
    case $issue_flag in
        -i)
            git config branch.$name.issue $issue
            echo "`txtgreen Issue` `txtyellow \#$issue` `txtgreen "is assigned to the task"`"
        ;;
        -m)
            local ghi_out=$(ghi open  --claim  $labels  "${@:2}")
            local number=$(echo $ghi_out | grep '#' | sed 's/^#\([0-9]*\):.*$/\1/')
            if [ "$number" ]; then 
                git config branch.$name.issue $number
                ghi show $number
                echo "`txtgreen Issue` `txtyellow \#$number` `txtgreen "is assigned to the task"`"
            fi
        ;;
    esac
}
function gtt_task_connect() {
    while (( $# )); do
        case $1 in
            -h)
                [ ! $2 ] && err "Need an argument for -h: branch that you want to connect"
                local head=$2
                ;;
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name"
                local base=$2
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number"
                local issue=$2
                ;;
            *)
                err "Wrong options"
                ;;
        esac
        shift 2
    done
    local head=${head:-$(current_branch)}
    local base=${base:-master}
    local issue=${issue:-$(git config branch.$head.issue)}
    if [ -z "$issue" ]; then
        txtred "Please provide issue number with -i option:\n"
        ghi list && exit 1
    fi

    git config branch.$head.issue $issue
    echo "`txtgreen Issue` `txtyellow \#$issue` `txtgreen "is assigned to the task"` `txtblue [$head]`"
    ghi edit --head $head --base $base $issue
    if (( $? != 0 )); then 
        txtred "Couldn't transform issue to pull-request. "
        echo "Push commits and try to connect again"
    fi
}
function gtt_task_close() {
    local task=$(current_branch)
    [ "$task" == "master" ] && err "You are on [master] branch. Swith to the task, that you want to close"

    local dirty=$(git status -s)
    [ "$dirty" ] && err "You have uncommited changes. Please, commit them first"

    while (( $# )); do
        case $1 in
            -b)
                [ ! $2 ] && err "Need an argument for -b: base branch name"
                local base=$2
                ;;
            -i)
                [ ! $2 ] && err "Need an argument for -i: issue number"
                local issue=$2
                git config branch.$task.issue $issue
                ;;
            *)
                err "Wrong options"
                ;;
        esac
        shift 2
    done
    local base=${base:-master}
    local issue=${issue:-$(git config branch.$task.issue)}
    if [ ! "$issue" ]; then 
        txtred "Task is not connected to any issue."
        echo " Choose one of existing and use '-i <number>' option or create a new one"
        ghi list && exit 1
    fi
    local step1="`txtbold 1.` Try to merge `txtblue [$task]` into `txtgreen [$base]`"
    local step2="`txtbold 2.` Push `txtblue [$task]` branch"
    local step3="`txtbold 3.` Transform issue `txtyellow \#${issue}` into a pull-request"
    local step4="`txtbold 4.` Push `txtgreen [$base]` branch and timetracker notes (it will close issue `txtyellow \#${issue}`)"
    local step5="`txtbold 5.` Delete `txtblue [$task]` task and move the time remained on it to `txtblue [$base]`"
    overview "$step1" "$step2" "$step3" "$step4" "$step5" 

    echo "$step1"
    git checkout $base
    git merge --no-ff $task
    failed $? "Couldn't merge branch [$task] into [$base]"

    echo "$step2"
    git push -u origin $task
    failed $? "Couldn't push [$task] branch to remote origin"

    echo "$step3"
    gtt_task_connect -h $task -b $base -i $issue
    failed $?

    echo "$step4"
    git push origin $base
    failed $? "Couldn't push [$base] branch to remote origin"
    git push
    failed $? "Couldn't push timetracker notes"

    echo "$step5"
    spent_set $(( $(spent_get) + $(git config branch.$task.spent) ))
    git branch -d $task
    failed $? "Couldn't delete branch [$task]"

    ghi show $issue
}
function gtt_task_switch() {
    local issue=$1
    [ ! "$issue" ] && gtt_list && err "Choose task you want to switch to and use it's issue number or '-' for [master] branch"
    [ "$issue" == "-" ] && git checkout master

    local task=$(git config --get-regexp "branch.*.issue" | grep " $issue$" | cut -d "." -f 2)
    [ ! "$task" ] && gtt_list && err "No task #$issue. Create a new one or choose from existing."
    git checkout $task
}
function gtt_task_show() {
    local issue=$(git config branch.$(current_branch).issue)
    [ "$1" == "-w" ] && web="-w"
    ghi show $issue $web
}

function gtt_addhooks() {
    [ ! "$(gitdir)" ] && err "It's not a git root directory!"

    local hooksdir="$(gitdir)/hooks"
    [ ! -d $hooksdir ] && mkdir $hooksdir

    local pre_commit="$hooksdir/pre-commit"
    pre_commit_hook > $pre_commit
    chmod +x $pre_commit

    local post_commit="$hooksdir/post-commit"
    post_commit_hook > $post_commit
    chmod +x $post_commit

    local post_merge="$hooksdir/post-merge"
    post_merge_hook > $post_merge
    chmod +x $post_merge

    local post_checkout="$hooksdir/post-checkout"
    post_checkout_hook > $post_checkout
    chmod +x $post_checkout

    txtgreen "Hooks created: "
    echo "pre-commit, post-commit, post-merge, post-checkout"
}
function gtt_config() {
    local remote=${1:-origin}
    local branches=$(git for-each-ref refs/heads/ --format='%(refname:short)')
    [ ! "$branches" ] && err "Looks like an empty repository. Make an init commit and try again."

    local push="refs/notes/timetracker:refs/notes/timetracker"
    local exists=$(git config --get-all remote.$remote.push | grep "$push")
    [ ! "$exists" ] && git config --add remote.$remote.push $push

    local fetch="+refs/notes/timetracker:refs/notes/remotes/$remote/timetracker"
    local exists=$(git config --get-all remote.$remote.fetch | grep "$fetch")
    [ ! "$exists" ] && git config --add remote.$remote.fetch $fetch

    git config notes.rewriteRef "refs/notes/timetracker"
    git config notes.displayRef "refs/notes/timetracker"
    config_set branch $(current_branch)

    for branch in $branches; do
        spent_get $branch &> /dev/null
        # spent_set $(spent_get $branch) $branch
    done

    txtgreen "Git timetrack is configured. "
    echo "Now run git pull if you don't want problems"
}

#############

(( $# == 0 )) && gtt_list && exit 0

subcommand=$1
shift

case $subcommand in
    stop|-p)
        gtt_stop
        exit 0
    ;;
    usage|-h|--help|help)
        show_help
        exit 0
    ;;
    prompt-status)
        if [ "$(git config timetrack.branch)" ]; then 
            on_status && human_time $(current_time) --short 
        else
            txtgray "%15s" $(date +%T)
        fi
        exit 0
    ;;
esac

[ ! $(gitdir) ] && err "It's not a git root directory!"
case $subcommand in
    start)
        gtt_start
    ;;
    current)
        gtt_current "$@"
    ;;
    reset)
        gtt_reset
    ;;
    set)
        gtt_set "$@"
        gtt_current
    ;;
    add)
        gtt_add "$@"
        gtt_current
    ;;
    list)
        gtt_list
    ;;
    ammend)
        sha=${1:?"need commit sha"}
        gtt_stop
        spent=$(spent_get)
        running=$(config_get start)
        gtt_reset

        if [ $spent ]; then 
            git notes --ref timetracker add -f -m "Time-spent: $spent" $sha
            echo "Time spent: $(human_time $spent)"
        fi
        [ $running ] && config_set start $(date +%s)
    ;;
    delete)
        git notes --ref timetracker remove ${1:-HEAD}
    ;;
    summary)
        gtt_summary "$@"
    ;;
    log)
        git log --color "$@" | sed "s/Time-spent: \([0-9]\+\)/git timetrack human-time \1/e" | less -R
    ;;
    timesince)
        current_date=$(date +%s)
        last=$(git log HEAD~${1:-0} -1 --format=%ct)
        t=$(( current_date - last ))
        gtt_set $(( $t / 60 ))
        gtt_current
    ;;
    human-time)
        human_time ${1:?"need time in seconds"}
    ;;
    addhooks)
        gtt_addhooks
    ;;
    config)
        gtt_config
    ;;
    init)
        gtt_addhooks
        gtt_config
    ;;
    merge)
        git notes --ref timetracker merge "refs/notes/remotes/${1:-origin}/timetracker"
    ;;
    task)
        subsubcommand=$1
        shift
        case $subsubcommand in
            new)
                gtt_task_new "$@"
            ;;
            connect)
                gtt_task_connect "$@"
            ;;
            close)
                gtt_task_close "$@"
            ;;
            switch)
                gtt_task_switch "$@"
            ;;
            show|*)
                gtt_task_show "$@"
            ;;
        esac
    ;;
    *)
        txtred "Wrong subcommand: "; echo "$subcommand"
        show_help
    ;;
esac
